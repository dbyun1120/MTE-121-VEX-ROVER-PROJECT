float Normalize_Angle(float a) 
{
  while(a >  M_PI) a -= 2*M_PI;
  while(a < -M_PI) a += 2*M_PI;
  return a;
}

void Return_To_Origin(float &x, float &y, float &theta) {

    float angle_to_origin = atan2(-y, -x);

    float turn_angle = normalizeAngle(angle_to_origin - theta);
    float turn_degrees = turn_angle * 180.0 / M_PI;

    // Turn in place
    leftMotor.spinFor(reverse,  turn_degrees/360.0, turns);
    rightMotor.spinFor(forward, turn_degrees/360.0, turns);

    float distance = sqrt(x*x + y*y);
    const int wheel_circumference = 20; //cm
    float wheel_turns = distance / wheel_circumference;

    // Drive forward to the origin
    leftMotor.spinFor(forward, wheel_turns, turns);
    rightMotor.spinFor(forward, wheel_turns, turns);

}

void driveDelta(float dx, float dy, float &x, float &y, float &theta) 
{
    float target_x = x + dx;
    float target_y = y + dy;

    float angle = atan2(target_y - y, target_x - x);
    float turn_angle = normalizeAngle(angle - theta);
    float turn_degrees = turn_angle * 180.0 / M_PI;

    // Turn in place
    leftMotor.spinFor(reverse,  turn_degrees/360.0, turns, false);
    rightMotor.spinFor(forward, turn_degrees/360.0, turns);

    float distance = sqrt(dx*dx + dy*dy);
    float wheel_turns = distance / wheel_circumference;

    // Drive straight
    leftMotor.spinFor(forward, wheel_turns, turns);
    rightMotor.spinFor(forward, wheel_turns, turns);

}

while(true) 
{

    // --- 1. GET WHEEL ROTATIONS ---
    float left_rotation = leftMotor.position(turns);
    float right_rotation = rightMotor.position(turns);

    float dL = (left_rotation  - prev_left_rotation)  * wheel_circumference;
    float dR = (right_rotation - prev_right_rotation) * wheel_circumference;

    prev_left_rotation = left_rotation;
    prev_right_rotation = right_rotation;

    float distance_forward = (dL + dR) / 2.0;

    // --- 2. HEADING (use inertial sensor) ---
    theta = BrainInertial.heading(degrees) * M_PI / 180.0;

    // --- 3. UPDATE POSITION ---
    x += distance_forward * cos(theta);
    y += distance_forward * sin(theta);

    // --- 4. BUMPER BEHAVIOR ---
    if(Bumper.pressing()) {

        // BACK UP a little bit
        leftMotor.spinFor(reverse, 0.2, turns, false);
        rightMotor.spinFor(reverse, 0.2, turns);

        // MOVE +5 in X
        driveDelta(5.0, 0.0, x, y, theta);

        // MOVE +5 in Y
        driveDelta(0.0, 5.0, x, y, theta);
    }

}
























int num_scans = 0;
//remote control sets the number of scans. say num_scans = 3

int*** arrays = new int**[num_scans];

for(int i = 0; i < num_scans; i++){
    arrays[i] = new int*[128];
    for(int r = 0; r < 128; r++){
        arrays[i][r] = new int[128];
    }
}











