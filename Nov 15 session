#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START IQ MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END IQ MACROS


// Robot configuration code.
inertial BrainInertial = inertial();
motor rightMotor = motor(PORT6, true);
motor leftMotor = motor(PORT1, false);
controller Controller = controller();
motor armMotor = motor(PORT4, false);
distance Distance7 = distance(PORT5);
motor DistanceMotor = motor(PORT2, false);


// generating and setting random seed
void initializeRandomSeed(){
  wait(100,msec);
  double xAxis = BrainInertial.acceleration(xaxis) * 1000;
  double yAxis = BrainInertial.acceleration(yaxis) * 1000;
  double zAxis = BrainInertial.acceleration(zaxis) * 1000;
  // Combine these values into a single integer
  int seed = int(
    xAxis + yAxis + zAxis
  );
  // Set the seed
  srand(seed); 
}



void vexcodeInit() {

  // Initializing random seed.
  initializeRandomSeed(); 
}


// define variable for remote controller enable/disable
bool RemoteControlCodeEnabled = true;
// define variables used for controlling motors based on controller inputs
bool ControllerRightShoulderControlMotorsStopped = true;

// define a task that will handle monitoring inputs from Controller
int rc_auto_loop_function_Controller() {
  // process the controller input every 20 milliseconds
  // update the motors based on the input values
  while(true) {
    if(RemoteControlCodeEnabled) {
      // check the ButtonRUp/ButtonRDown status to control armMotor
      if (Controller.ButtonRUp.pressing()) {
        armMotor.spin(forward);
        ControllerRightShoulderControlMotorsStopped = false;
      } else if (Controller.ButtonRDown.pressing()) {
        armMotor.spin(reverse);
        ControllerRightShoulderControlMotorsStopped = false;
      } else if (!ControllerRightShoulderControlMotorsStopped) {
        armMotor.stop();
        // set the toggle so that we don't constantly tell the motor to stop when the buttons are released
        ControllerRightShoulderControlMotorsStopped = true;
      }
    }
    // wait before repeating the process
    wait(20, msec);
  }
  return 0;
}

task rc_auto_loop_task_Controller(rc_auto_loop_function_Controller);

#pragma endregion VEXcode Generated Robot Configuration

//----------------------------------------------------------------------------
//                                                                            
//    Module:       main.cpp                                                  
//    Author:       {author}                                                  
//    Created:      {date}                                                    
//    Description:  IQ project                                                
//                                                                            
//----------------------------------------------------------------------------

// Include the IQ Library
#include "iq_cpp.h"

// Allows for easier use of the VEX Library
using namespace vex;

void calibrate_screen()
{
  Brain.Screen.setCursor(2, 1);
  Brain.Screen.clearScreen();
}



void movement(double left_stick_position, double right_stick_position)
{
  double moving_value = left_stick_position;
  double turning_value = right_stick_position ; // change the 10 to other stuff, this is to avoid having left on 100 and right on0 or vice versa
  double left_motor_speed = moving_value + turning_value - (turning_value/2);
  double right_motor_speed = moving_value - turning_value + (turning_value/2);

  leftMotor.setVelocity(left_motor_speed/2,percent);
  rightMotor.setVelocity(right_motor_speed/2,percent);

  leftMotor.spin(forward);
  rightMotor.spin(forward);
  /*

  move left trigger up and down to control moving fwd and bwd
  move right trigger left and right to control turning left and right
  example, if left is straight up and right trigger is to the right.

  moving value = 100 (fwd positive) and turning_value = 100(right positive i think)
  left_motor = 100 and right motor is 10 (100-90 since we made turning_value right_stick_position - 10)
  so it turns to the right
  */
}
void turning(double right_stick_position)
{ 
  leftMotor.setVelocity(50,percent);
  rightMotor.setVelocity(50,percent);
  if (right_stick_position > 0)
  {
    leftMotor.spin(forward);
    rightMotor.spin(reverse);
  }
  else if (right_stick_position < 0)
  {
    leftMotor.spin(reverse);
    rightMotor.spin(forward);
  }
  else
  {
    leftMotor.stop();
    rightMotor.stop();
  }
}





void setup_scans(int& scan_press)
{
 bool setup = true;

  calibrate_screen();
  while (setup)
  {
    calibrate_screen();

    Brain.Screen.print("Scans : %d", scan_press);


    if (Controller.ButtonEDown.pressing())
    {
      Brain.Screen.setCursor (4,1);
      Brain.Screen.print("Scan Confirmed");
      wait(1,seconds);
      setup=false;
    }
    

    if (Controller.ButtonEUp.pressing())
    {
      scan_press+=1;
      while (Controller.ButtonEUp.pressing())
      {
        wait (50,msec);
      }
    }


    wait(75,msec);
  }
}

int level_reducer(int level_press)
{
  int modulus = level_press % 2;
  if (modulus == 1)
  {
    return 1;
  }
  else
  {
    return 2;
  }
}

void setup_level(int& level_press, int& level_n)
{
 bool setup = true;

  calibrate_screen();
  while (setup)
  {
    calibrate_screen();
    level_n = level_reducer(level_press);
    Brain.Screen.print("Level : %d", level_n);


    if (Controller.ButtonFDown.pressing())
    {
      Brain.Screen.setCursor (4,1);
      Brain.Screen.print("Level Confirmed");
      level_n = level_reducer(level_press);

      wait(0.5,seconds);
      setup=false;
    }
    

    if (Controller.ButtonFUp.pressing())
    {
      level_press+=1;
      while (Controller.ButtonFUp.pressing())
      {
        wait (50,msec);
      }
    }


    wait(75,msec);
  }
}

void armup()
{
armMotor.setVelocity(100,percent);
armMotor.spin(forward);

}
void armdown()
{
  armMotor.setVelocity(50,percent);
  armMotor.spin(reverse);

}

void Update_Position(const float wheel_circumference, float &x, float &y, float &theta, float &prev_left_rotation, float &prev_right_rotation)
{
  float left_rotation = leftMotor.position(turns);
  float right_rotation = rightMotor.position(turns);

  float difference_left = (left_rotation - prev_left_rotation)*wheel_circumference; 
  float difference_right = (right_rotation - prev_right_rotation)*wheel_circumference; 
  prev_left_rotation = left_rotation;
  prev_right_rotation = right_rotation; 

  //distance the middle of the robot travels forward
  float distance_forward = (difference_left + difference_right)/2.0;

  //convert angle to radians
  theta = BrainInertial.heading(degrees) * M_PI / 180.0;

  x += distance_forward * cos(theta);
  y += distance_forward * sin(theta);
}

void position_print(double x, double y, double theta)
{

    Brain.Screen.clearScreen(); 
    Brain.Screen.setCursor(1, 1);
    Brain.Screen.print("X: %.2f cm", x);
    Brain.Screen.newLine();
    Brain.Screen.print("Y: %.2f cm", y);
    Brain.Screen.newLine();
    Brain.Screen.print("Heading: %.2f deg", theta*180/M_PI);
  
}
void start_scan(bool &direction)
{
  //Motor spins counterclockwise
  if (direction){
    DistanceMotor.spinFor(forward, 360, degrees);
    wait(50, msec);
  }
  else
  {
    DistanceMotor.spinFor(reverse, 360, degrees);
    wait(50, msec);
  }
  direction = !direction;

}

void scan_to_array(float &x, float &y, double scan_info[20][20], bool& direction)
{

  DistanceMotor.setPosition(0, degrees);

  start_scan(direction);

  while(DistanceMotor.isSpinning()){
    float angle_deg = DistanceMotor.position(degrees);
    float angle_radians = angle_deg * (M_PI/180); 
    
    if(Distance7.isObjectDetected())
    {
      float distance_cm = Distance7.objectDistance(mm)/10.0;

      // Object coordinates relative to the robotâ€™s current location
      int x_obj = x + (int)(distance_cm * cos(angle_radians));
      int y_obj = y + (int)(distance_cm * sin(angle_radians));

      // Stay inside map boundaries
      //Since we can now map relative to the robot's position,
      //we can make the grid wayyy bigger, like 1m x 1m. 20cm x 20cm is tiny 
      //These values are changeable to the size of the actual grid map we want
      if (x_obj >= 0 && x_obj < 20 && y_obj >= 0 && y_obj < 20) 
      {
        scan_info[y_obj][x_obj] = 1; // mark obstacle
      }
      else
      {
        scan_info[y_obj][x_obj] = 0; 

      }
    }
  }
  wait(1,seconds);
  calibrate_screen();
  start_scan(direction);
for(int i = 0; i < 20; i++) {
  for(int j = 0; j < 20; j++) {
    Brain.Screen.print("%d ", (int)scan_info[i][j]); 
  }
  Brain.Screen.newLine();
}
  wait(5,seconds);

}



int main() {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();
  // Begin project code
  int scan_press = 1;
  int level_press = 1;
  const float wheel_circumference = 20; //cm

  float x = 0.0;
  float y = 0.0;
  float theta = 0.0;
  bool display_position = false; 


  float prev_left_rotation = 0.0;
  float prev_right_rotation = 0.0;


  BrainInertial.setHeading(0, degrees);
  leftMotor.setPosition(0, degrees);
  rightMotor.setPosition(0, degrees);
  bool direction = true;


  calibrate_screen();
  RemoteControlCodeEnabled = true;
  setup_scans(scan_press);
  calibrate_screen();
  int level_n = 0;
  setup_level(level_press,level_n);
  calibrate_screen();

  Brain.Screen.print("Scans : %d", scan_press);
  Brain.Screen.setCursor (4,1);
  Brain.Screen.print("level : %d", level_n);

  calibrate_screen();

  leftMotor.setVelocity(50,percent);
  rightMotor.setVelocity(50,percent);
  DistanceMotor.setVelocity(20,percent);

  double scan_info[20][20];
  for (int i; i<20; i++)
  {
    for (int j; j<20;j++)
    {
      scan_info[i][j]=0;
    }
  }

  

  bool go = true;
  while (go)
  {
    display_position = true;
    double left_stick = Controller.AxisA.position(); // AxisA is vert for left
    double right_stick = Controller.AxisC.position(); // AxisC is hor for right
    Update_Position(wheel_circumference, x, y, theta, prev_left_rotation, prev_right_rotation);
    if (display_position)
    {
      position_print(x, y, theta);
    }
    if (left_stick !=0 && right_stick !=0 || (left_stick !=0 && right_stick == 0))
    {
    movement(left_stick,right_stick);  
    }
    else if (left_stick == 0 && right_stick !=0)
    {
      turning(right_stick);
    }
    else
    {
      
      leftMotor.stop(hold);
      rightMotor.stop(hold);
      if (Controller.ButtonLUp.pressing())
      {
        scan_to_array(x, y, scan_info, direction);
        wait(.2,seconds);
      }
      if (Controller.ButtonRUp.pressing())
      {
        armup();
        armMotor.stop();

      }
      if (Controller.ButtonRDown.pressing())
      {
        armdown();
        armMotor.stop();

      }
      if (!Controller.ButtonRDown.pressing() && !Controller.ButtonRUp.pressing())
      {
        armMotor.stop();

      }
    }
    wait(0.25,seconds);
  
  // for now just stop program with brain button
  }



}
