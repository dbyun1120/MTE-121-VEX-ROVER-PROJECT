#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START IQ MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END IQ MACROS


// Robot configuration code.
inertial BrainInertial = inertial();
motor rightMotor = motor(PORT6, true);
motor leftMotor = motor(PORT1, false);
controller Controller = controller();
motor armMotor = motor(PORT4, false);
distance Distance5 = distance(PORT5);
motor DistanceMotor = motor(PORT2, false);


// generating and setting random seed
void initializeRandomSeed(){
  wait(100,msec);
  double xAxis = BrainInertial.acceleration(xaxis) * 1000;
  double yAxis = BrainInertial.acceleration(yaxis) * 1000;
  double zAxis = BrainInertial.acceleration(zaxis) * 1000;
  // Combine these values into a single integer
  int seed = int(
    xAxis + yAxis + zAxis
  );
  // Set the seed
  srand(seed); 
}



void vexcodeInit() {

  // Initializing random seed.
  initializeRandomSeed(); 
}

#pragma endregion VEXcode Generated Robot Configuration

//----------------------------------------------------------------------------
//                                                                            
//    Module:       main.cpp                                                  
//    Author:       {author}                                                  
//    Created:      {date}                                                    
//    Description:  IQ project                                                
//                                                                            
//----------------------------------------------------------------------------

// Include the IQ Library
#include "iq_cpp.h"

// Allows for easier use of the VEX Library
using namespace vex;

void calibrate_screen()
{
  Brain.Screen.setCursor(2, 1);
  Brain.Screen.clearScreen();
  Brain.Screen.setPenColor(white);
}



void movement(double left_stick_position, double right_stick_position)
{
  double moving_value = left_stick_position;
  double turning_value = right_stick_position ; // change the 10 to other stuff, this is to avoid having left on 100 and right on0 or vice versa
  double left_motor_speed = moving_value + turning_value - (turning_value/2);
  double right_motor_speed = moving_value - turning_value + (turning_value/2);

  leftMotor.setVelocity(left_motor_speed/2,percent);
  rightMotor.setVelocity(right_motor_speed/2,percent);

  leftMotor.spin(forward);
  rightMotor.spin(forward);
  /*

  move left trigger up and down to control moving fwd and bwd
  move right trigger left and right to control turning left and right
  example, if left is straight up and right trigger is to the right.

  moving value = 100 (fwd positive) and turning_value = 100(right positive i think)
  left_motor = 100 and right motor is 10 (100-90 since we made turning_value right_stick_position - 10)
  so it turns to the right
  */
}
void turning(double right_stick_position)
{ 
  leftMotor.setVelocity(50,percent);
  rightMotor.setVelocity(50,percent);
  if (right_stick_position > 0)
  {
    leftMotor.spin(forward);
    rightMotor.spin(reverse);
  }
  else if (right_stick_position < 0)
  {
    leftMotor.spin(reverse);
    rightMotor.spin(forward);
  }
  else
  {
    leftMotor.stop();
    rightMotor.stop();
  }
}





void setup_scans(int& scan_amount)
{
 bool setup = true;

  calibrate_screen();
  while (setup)
  {
    calibrate_screen();

    Brain.Screen.print("Scans : %d", scan_amount);


    if (Controller.ButtonEDown.pressing())
    {
      Brain.Screen.setCursor (4,1);
      Brain.Screen.print("Scan Confirmed");
      wait(1,seconds);
      setup=false;
    }
    

    if (Controller.ButtonEUp.pressing())
    {
      scan_amount+=1;
      while (Controller.ButtonEUp.pressing())
      {
        wait (50,msec);
      }
    }


    wait(75,msec);
  }
}

int level_reducer(int level_press)
{
  int modulus = level_press % 2;
  if (modulus == 1)
  {
    return 1;
  }
  else
  {
    return 2;
  }
}

void setup_level(int& level_press, int& level_n)
{
 bool setup = true;

  calibrate_screen();
  while (setup)
  {
    calibrate_screen();
    level_n = level_reducer(level_press);
    Brain.Screen.print("Level : %d", level_n);


    if (Controller.ButtonFDown.pressing())
    {
      Brain.Screen.setCursor (4,1);
      Brain.Screen.print("Level Confirmed");
      level_n = level_reducer(level_press);

      wait(0.5,seconds);
      setup=false;
    }
    

    if (Controller.ButtonFUp.pressing())
    {
      level_press+=1;
      while (Controller.ButtonFUp.pressing())
      {
        wait (50,msec);
      }
    }


    wait(75,msec);
  }
}



void Update_Position(const float wheel_circumference, float &x, float &y, float &theta, float &prev_left_rotation, float &prev_right_rotation)
{
  float left_rotation = leftMotor.position(turns);
  float right_rotation = rightMotor.position(turns);

  float difference_left = (left_rotation - prev_left_rotation)*wheel_circumference; 
  float difference_right = (right_rotation - prev_right_rotation)*wheel_circumference; 
  prev_left_rotation = left_rotation;
  prev_right_rotation = right_rotation; 

  //distance the middle of the robot travels forward
  float distance_forward = (difference_left + difference_right)/2.0;

  //convert angle to radians
  theta = BrainInertial.heading(degrees) * M_PI / 180.0;

  x += distance_forward * cos(theta);
  y += distance_forward * sin(theta);
}


void reset_map(bool scan_info[128][128])
{
   for (int i = 0; i<128; i++)
  {
    for (int j = 0; j<128;j++)
    {
      scan_info[i][j]=0;
    }
  }
}



void position_print(double x, double y, double theta)
{

    Brain.Screen.clearScreen(); 
    Brain.Screen.setCursor(1, 1);
    Brain.Screen.print("X: %.2f cm", x);
    Brain.Screen.newLine();
    Brain.Screen.print("Y: %.2f cm", y);
    Brain.Screen.newLine();
    Brain.Screen.print("Heading: %.2f deg", theta*180/M_PI);
  
}

void draw_map_data(bool scan_info[128][128])
{
  calibrate_screen();
  Brain.Screen.setPenColor(blue);

  Brain.Screen.drawLine(10,0,10,128);
  Brain.Screen.drawLine(140,0,140,128);

  Brain.Screen.setPenColor(red);

  for (int i=0; i<128; i++)
  {
    for (int j=0; j<128; j++)
    {
      if (scan_info[i][j])
      {
        Brain.Screen.drawPixel(j+20,i-20);
      }
    }
  }
  while (!Controller.ButtonRUp.pressing())
  {}
  while (Controller.ButtonRUp.pressing())
  {}

  reset_map(scan_info);
}


void scan_to_array(bool scan_info[128][128])
{

  DistanceMotor.setPosition(0, degrees);
  DistanceMotor.spin(reverse);
  while(DistanceMotor.position(degrees) > -360 ){
    
    float angle_deg = DistanceMotor.position(degrees);
    float angle_radians = angle_deg * (M_PI/180); 
    
    if(Distance5.isObjectDetected())
    {
      float distance_cm = Distance5.objectDistance(mm)/10.0;

      float dx = (distance_cm * sin(angle_radians));
      float dy = -(distance_cm * cos(angle_radians));


      

      // Object coordinates relative to the robotâ€™s current location
      int x_obj = (83 - (int)(dx))*2/3;
      int y_obj = (117 + (int)(dy))*2/3;


      calibrate_screen();
      Brain.Screen.print("Scanning...");



      if (x_obj >= 0 && x_obj < 128 && y_obj >= 0 && y_obj < 128) 
      {
        scan_info[y_obj][x_obj] = 1; // mark obstacle
      }
    }
    wait (20,msec);

  }
  DistanceMotor.stop(hold);
  wait(1,seconds);
  DistanceMotor.spinFor(forward, 360, degrees);

  calibrate_screen();
  
  draw_map_data(scan_info);
  

}

void raise_bot(int level_n)
{ 
  armMotor.setVelocity(100,percent);
  if (level_n == 2)
  {
    armMotor.spin(forward);
  }
}

void lower_bot()
{
    armMotor.setVelocity(50,percent);
    armMotor.spin(reverse);
    wait(5,seconds);
    armMotor.stop();
}

void shut_down () {
    Brain.Screen.print("Limit reached.");
    Brain.Screen.newLine();
    Brain.Screen.print("Shutting down.");
    lower_bot();
    Brain.Screen.clearScreen();
    Brain.Screen.setCursor(1, 1);


    leftMotor.stop();
    rightMotor.stop();
    armMotor.stop();
    wait(1000, msec);
    Brain.programStop();
}




int main() {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();
  // Begin project code
  int scan_amount = 1;
  int level_press = 1;
  const float wheel_circumference = 20; //cm

  float x = 0.0;
  float y = 0.0;
  float theta = 0.0;
  bool display_position = false; 


  float prev_left_rotation = 0.0;
  float prev_right_rotation = 0.0;


  BrainInertial.setHeading(0, degrees);
  leftMotor.setPosition(0, degrees);
  rightMotor.setPosition(0, degrees);


  calibrate_screen();
  setup_scans(scan_amount);
  calibrate_screen();
  int level_n = 0;
  setup_level(level_press,level_n);
  calibrate_screen();

  Brain.Screen.print("Scans : %d", scan_amount);
  Brain.Screen.setCursor (4,1);
  Brain.Screen.print("level : %d", level_n);

  calibrate_screen();

  leftMotor.setVelocity(50,percent);
  rightMotor.setVelocity(50,percent);
  DistanceMotor.setVelocity(10,percent);

  raise_bot(level_n);
  if (level_n == 2)
  {
    Brain.Screen.print("Raising Arm...");
    wait(8,seconds);
  }
  bool scan_info[128][128];
  reset_map(scan_info);



  

  bool go = true;
  int current_scans = 0;
  Brain.Timer.reset();
  while (go)
  {
    
    display_position = true;
    double left_stick = Controller.AxisA.position(); // AxisA is vert for left
    double right_stick = Controller.AxisC.position(); // AxisC is hor for right
    int deadzone = 5;
    if (fabs(left_stick) < deadzone) 
    {
      left_stick = 0;
    }
    if (fabs(right_stick) < deadzone) 
    {
      right_stick = 0;
    }
    Update_Position(wheel_circumference, x, y, theta, prev_left_rotation, prev_right_rotation);
    if (display_position)
    {
      position_print(x, y, theta);
    }
    if (left_stick !=0)
    {
    Brain.Timer.reset();
    movement(left_stick,right_stick);  
    }
    else if (left_stick == 0 && right_stick !=0)
    {
      Brain.Timer.reset();
      turning(right_stick);
    }
    else
    {
      if (Brain.Timer.value() >= 60)
      {
      Brain.Screen.clearScreen();
      Brain.Screen.setCursor(1, 1);
      Brain.Screen.print("Idled for too long.");
      wait(1,seconds);
      shut_down();
      }
      leftMotor.stop(hold);
      rightMotor.stop(hold);
     
      if (Controller.ButtonLUp.pressing() && current_scans < scan_amount)
      {
        Brain.Timer.reset();
        current_scans+=1;
        scan_to_array(scan_info);
        calibrate_screen();
        wait(.2,seconds);
        Brain.Timer.reset();

      }
       if (current_scans >= scan_amount)
      {
        shut_down();
      }
      
    }
    wait(0.25,seconds);
  
  // for now just stop program with brain button
  }



}
